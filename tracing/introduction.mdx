---
title: LLM Observability with Laminar Tracing
sidebarTitle: Introduction
description: Comprehensive observability for your LLM applications with OpenTelemetry-based tracing
---

## What is Laminar Tracing?

<div style={{ border: '1px solid #2B2B30', borderRadius: '8px', overflow: 'hidden' }}>
<img src="/images/traces/traces.png" alt="Screenshot of a trace visualization" style={{ margin: '0px' }}/>
</div>

Laminar offers comprehensive observability for your LLM applications, capturing the entire execution flow with minimal setup. This allows you to:

- **Debug complex Agents and LLM workflows** by seeing exactly how data flows through your application
- **Monitor performance** with detailed execution time and token usage metrics
- **Track costs** across different models and components
- **Analyze user sessions** to understand and improve the end-user experience

## Key Concepts

Example of a trace view on the Laminar platform:

<div style={{ border: '1px solid #2B2B30', borderRadius: '8px', overflow: 'hidden' }}>
<img src="/images/traces/trace-view.png" alt="Screenshot of a trace visualization" style={{ margin: '0px' }}/>
</div>

### Span

A single operation in your application's execution flow, such as LLM call, function call, or API request. In the screenshot above, the spans are the nodes in the tree view.
Selected span `gemini.generate_content` is highlighted in red and represents the LLM call to Gemini model.

Each span has:

- **Name**: The name of the span (e.g., `gemini.generate_content`)
- **Input**: The input of the function representing a span. In case of an LLM call, this is the prompt.
- **Output**: The output of the function representing a span. In case of an LLM call, this is the response from the model.
- **Duration**: How long the operation took to execute.
- **Path**: Hierarchical path of the span in the trace (e.g., `get_user.validate.api_call`).
- **Attributes**: Input parameters, return values, and other metadata.
- **Parent span ID**: A reference to the parent span. If the span is the root span of the trace, the parent span ID is not specified.

#### Span lifecycle

Spans are created, can optionally be activated, and need to be ended.

**Span creation** also known as **starting a span** is a process of creating a new span object with a start timestamp.
**Span activation** means setting the span as the current active span. This means that spans created afterwards will become the children of the current span.
**Span ending** is a process of setting the end timestamp on the span and closing the span.

<Note>
**Analogy:** 
- **Active Span:** You create a folder and immediately open it. Any file you save now goes inside that folder automatically.
- **Manual Span:** It's like creating a folder on your desktop but not opening it. If you save a file, it still goes to the desktop, not inside your new folder.
</Note>

<Tip>
A span that is not ended will never be visible in the UI.
</Tip>

Note that it is not required to activate a span. For example, if you know a small operation will not have children spans, you can create it without activating it.
Ending such a span is still required. These spans do not have children spans, so they are sometimes called **leaf spans**. A common example of a leaf span is a simple LLM call.

### Trace

Trace is a collection of spans that form a complete execution path. In the screenshot above, spans of the trace are highlighted in blue.
Traces spans within a trace show parent-child relationships between operations, helping you understand how your code executes.

### Session

Laminar helps you group related traces belonging to the same user interaction or conversation under a session.
It can be used to group traces of a multi-turn conversation, or complex workflows.

## What Laminar Captures

For every execution of your application, Laminar automatically records:

### Performance Metrics
- Total execution time
- Per-span execution times
- Bottlenecks and slow operations

### LLM-Specific Data
- Token counts (input and output)
- Model information
- Cost calculations

### Inputs & Outputs
- Function parameters
- Return values
- Prompts and completions

### Execution Flow
- Parent-child relationships
- Complete call hierarchy
- Cross-service transactions

## Next Steps

Now that you understand the basics of Laminar tracing:

- Get started quickly with our [Quickstart Guide](/tracing/quickstart)
- Explore our integrations to see how Laminar works with your favorite tools:
    - [OpenAI](/tracing/integrations/openai)
    - [Anthropic](/tracing/integrations/anthropic)
    - [Gemini](/tracing/integrations/gemini)
    - [Langchain](/tracing/integrations/langchain)
    - [Next.js](/tracing/integrations/nextjs)
    - [Vercel AI SDK](/tracing/integrations/vercel-ai-sdk)
    - [LiteLLM](/tracing/integrations/litellm)
    - [Playwright](/tracing/integrations/playwright)
    - [Puppeteer](/tracing/integrations/puppeteer)
    - [Browser Use](/tracing/integrations/browser-use)
    - [Stagehand](/tracing/integrations/stagehand)
- Continue to [Trace Structure](/tracing/structure) to learn more about how to add structure to your traces
- Explore [Browser agent observability](/tracing/browser-agent-observability) to learn how to record browser sessions and sync them with agent execution steps
