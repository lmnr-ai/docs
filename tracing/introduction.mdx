---
title: LLM Observability with Laminar Tracing
sidebarTitle: Introduction
description: Comprehensive observability for your LLM applications with OpenTelemetry-based tracing
---

## What is Laminar Tracing?

<div style={{ border: '1px solid #2B2B30', borderRadius: '8px', overflow: 'hidden' }}>
<img src="/images/traces/traces.png" alt="Screenshot of a trace visualization" style={{ margin: '0px' }}/>
</div>

Laminar offers comprehensive observability for your LLM applications, capturing the entire execution flow with minimal setup. This allows you to:

- **Debug complex Agents and LLM workflows** by seeing exactly how data flows through your application
- **Monitor performance** with detailed execution time and token usage metrics
- **Track costs** across different models and components
- **Analyze user sessions** to understand and improve the end-user experience

## Key Concepts

Example of a trace view on the Laminar platform:

<div style={{ border: '1px solid #2B2B30', borderRadius: '8px', overflow: 'hidden' }}>
<img src="/images/traces/trace-view.png" alt="Screenshot of a trace visualization" style={{ margin: '0px' }}/>
</div>

### Span

A single operation in your application's execution flow, such as LLM call, function call, or API request. In the screenshot above, the spans are the nodes in the tree view.
Selected span `gemini.generate_content` is highlighted in red and represents the LLM call to Gemini model.

Each span has:

- **Name**: The name of the span (e.g., `gemini.generate_content`)
- **Input**: The input of the function representing a span. In case of an LLM call, this is the prompt.
- **Output**: The output of the function representing a span. In case of an LLM call, this is the response from the model.
- **Duration**: How long the operation took to execute
- **Path**: Hierarchical path of the span in the trace (e.g., `get_user.validate.api_call`).
- **Attributes**: Input parameters, return values, and other metadata

### Trace

Trace is a collection of spans that form a complete execution path. In the screenshot above, spans of the trace are highlighted in blue.
Traces spans within a trace show parent-child relationships between operations, helping you understand how your code executes.

### Session

Laminar helps you group related traces belonging to the same user interaction or conversation under a session.
It can be used to group traces of a multi-turn conversation, or a complex workflows.

## What Laminar Captures

For every execution of your application, Laminar automatically records:

### Performance Metrics
- Total execution time
- Per-span execution times
- Bottlenecks and slow operations

### LLM-Specific Data
- Token counts (input and output)
- Model information
- Cost calculations

### Inputs & Outputs
- Function parameters
- Return values
- Prompts and completions

### Execution Flow
- Parent-child relationships
- Complete call hierarchy
- Cross-service transactions

## Next Steps

Now that you understand the basics of Laminar tracing:

- Get started quickly with our [Quickstart Guide](/tracing/quickstart)
- Explore our integrations to see how Laminar works with your favorite tools:
    - [OpenAI](/tracing/integrations/openai)
    - [Anthropic](/tracing/integrations/anthropic)
    - [Gemini](/tracing/integrations/gemini)
    - [Langchain](/tracing/integrations/langchain)
    - [Next.js](/tracing/integrations/nextjs)
    - [Vercel AI SDK](/tracing/integrations/vercel-ai-sdk)
    - [LiteLLM](/tracing/integrations/litellm)
    - [Playwright](/tracing/integrations/playwright)
    - [Puppeteer](/tracing/integrations/puppeteer)
    - [Browser Use](/tracing/integrations/browser-use)
    - [Stagehand](/tracing/integrations/stagehand)
- Continue to [Trace Structure](/tracing/structure) to learn more about how to add structure to your traces
- Explore [Browser agent observability](/tracing/browser-agent-observability) to learn how to record browser sessions and sync them with agent execution steps
