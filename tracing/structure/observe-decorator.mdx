---
title: Observe Decorator/Wrapper
description:
---

The `@observe` decorator (Python) or `observe()` wrapper (JavaScript) is the simplest way to trace a function. It automatically:

- Creates a span when the function is called
- Names the span after the function (or a custom name you provide)
- Captures input arguments and return values
- Ends the span when the function returns
- Records exceptions if the function throws

## When to Use Observe vs Manual Spans

| Use `@observe` when... | Use manual spans when... |
|------------------------|--------------------------|
| Tracing a function call | Tracing code that isn't a function |
| You want automatic input/output capture | You need conditional span creation |
| The function name works as the span name | You need runtime-determined names |
| Simple, straightforward tracing | Fine-grained control over timing |

## Nesting Behavior

Observed functions automatically nest. If function A calls function B, and both are observed, B's span becomes a child of A's span. This happens through context propagation—Laminar tracks the "current" span and parents new spans to it.

You can mix `@observe` with manual spans. A manual span created inside an observed function becomes a child of that function's span.

---

## Example: Wrap Your Own Functions

For deeper visibility, wrap your own functions:

<Tabs items={['TypeScript', 'Python']}>
  <Tab title="TypeScript">
    ```typescript
    import { observe } from '@lmnr-ai/lmnr';

    const answerQuestion = (question) => observe(
      { name: 'answer_question' },
      async () => {
        const response = await client.chat.completions.create({
          model: "gpt-4o-mini",
          messages: [{ role: "user", content: question }],
        });
        return response.choices[0].message.content;
      }
    );

    await answerQuestion("What is the capital of France?");
    ```
  </Tab>
  <Tab title="Python">
    ```python
    from lmnr import observe

    @observe()
    def answer_question(question: str) -> str:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": question}],
        )
        return response.choices[0].message.content

    answer_question("What is the capital of France?")
    ```
  </Tab>
</Tabs>

Now you see `answer_question` as the parent operation with the OpenAI call nested inside it. Function inputs and outputs are captured automatically.

See also: [TypeScript observe](http://localhost:3000/sdk/typescript/observe#observe-options-fn-args) • [Python observe](http://localhost:3000/sdk/python/observe#observe)
