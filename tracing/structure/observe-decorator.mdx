---
title: Trace Functions
description:
---

The `@observe` decorator (Python) or `observe()` wrapper (TypeScript) is the simplest way to trace a function. It automatically:

- Creates a span when the function is called
- Names the span after the function (or a custom name you provide)
- Captures input arguments and return values
- Ends the span when the function returns
- Records exceptions if the function throws

## When to Use Observe vs Manual Spans

| Use `@observe` when... | Use manual spans when... |
|------------------------|--------------------------|
| Tracing a function call | Tracing code that isn't a function |
| You want automatic input/output capture | You need conditional span creation |
| The function name works as the span name | You need runtime-determined names |
| Simple, straightforward tracing | Fine-grained control over timing |

## Nesting Behavior

Observed functions automatically nest. If function A calls function B, and both are observed, B's span becomes a child of A's span. This happens through context propagationâ€”Laminar tracks the "current" span and parents new spans to it.

You can mix `@observe` with manual spans. A manual span created inside an observed function becomes a child of that function's span.

---

## Example

Wrap a function you own so it shows up as a parent operation with downstream spans (LLM calls, tools, etc.) nested inside it.

<Tabs items={['TypeScript', 'Python']}>
  <Tab title="TypeScript">
    ```typescript
    import { observe } from '@lmnr-ai/lmnr';

    const answerQuestion = (question: string) =>
      observe({ name: 'answerQuestion' }, async () => {
        const response = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [{ role: 'user', content: question }],
        });
        return response.choices[0].message.content;
      });

    await answerQuestion('What is the capital of France?');
    ```

    See also: [`observe(options, fn, ...args)`](/sdk/observe#ts-observe)
  </Tab>
  <Tab title="Python">
    ```python
    from lmnr import observe

    @observe()
    def answer_question(question: str) -> str:
        response = openai.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": question}],
        )
        return response.choices[0].message.content

    answer_question("What is the capital of France?")
    ```

    See also: [`@observe()`](/sdk/observe#py-observe)
  </Tab>
</Tabs>

## In the Laminar UI

- The observed function appears as a span (often the root span for the trace).
- Auto-instrumented work inside it (LLM calls, vector DB calls, etc.) appears as child spans.
- Function arguments are recorded as span input and the return value as span output (unless you disable or override recording).
