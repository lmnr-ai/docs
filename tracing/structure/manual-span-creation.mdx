---
title: Manual Span Creation
description: Creating and managing spans manually for fine-grained control
---

## Overview

Manual span creation gives you fine-grained control over span lifecycle, attributes, and hierarchies. This is useful for:

- **Fine-grained control** over span lifecycle and attributes
- **Integration with existing tracing** in codebases that already use OpenTelemetry
- **Custom span hierarchies** that don't fit the function-level `observe` pattern

<Tabs>
<Tab title="Python">

The `Laminar.start_as_current_span` method is a recommended way to create spans manually in Python.
It creates a new span and sets it as the current span using a context manager. Context manager properly starts and ends the span.

### Basic Usage

```python {7}
from lmnr import Laminar


def process_data(input_data):
  # ... your code here ...

    with Laminar.start_as_current_span(
        name="custom_operation", # name of the span
        input=input_data, # input of the span
        span_type="DEFAULT" # type of the span. If not specified, it will be `'DEFAULT'`
    ) as span:
        try:
            # ... your code here ...
            result = process_data(input_data)
            
            # Set span output and custom attributes
            Laminar.set_span_output(result)
            Laminar.set_span_attributes({
                "custom.result_count": len(result)
            })
            
        except Exception as error:
            # Record error on span
            span.record_exception(error) # This will create exception event on the span
            raise
```

### Parameters

- `name` (`str`): name of the span
- `input` (`Any`): input to the span. It will be serialized to JSON and recorded as span input
- `span_type` (`Literal['DEFAULT'] | Literal['LLM']`): type of the span. If not specified, it will be `'DEFAULT'`

### Manually creating an LLM span

To manually create an LLM span, set `span_type="LLM"` and properly set the span attributes related to LLM calls.
<Tip>
It's highly recommended to set input of manual LLM spans in the OpenAI's `messages` format to get see LLM calls-specific rendering in the UI.
</Tip>

```python
from lmnr import Laminar, Attributes
import requests

messages = [{
    "role": "user", 
    "content": "What is the longest river in the world?"
}]

with Laminar.start_as_current_span(
    name="custom_llm_call",
    input=messages,
    span_type="LLM"
):
    response = requests.post(
        "https://api.custom-llm.com/v1/completions",
        json={
            "model": "custom-model-1",
            "messages": messages,
        },
    ).json()

    Laminar.set_span_output(response["choices"][0]["message"]["content"])
    
    # Set LLM-specific attributes
    Laminar.set_span_attributes({
        Attributes.PROVIDER: "custom-llm.com",
        Attributes.REQUEST_MODEL: "custom-model-1", 
        Attributes.RESPONSE_MODEL: response["model"],
        Attributes.INPUT_TOKEN_COUNT: response["usage"]["input_tokens"],
        Attributes.OUTPUT_TOKEN_COUNT: response["usage"]["output_tokens"],
    })
```

</Tab>
<Tab title="JavaScript/TypeScript">

### startSpan Method

In JavaScript/TypeScript, use `Laminar.startSpan()` for manual span creation:

```javascript
import { Laminar } from '@lmnr-ai/lmnr';

// Create a span manually
const span = Laminar.startSpan({
  name: 'customOperation',
  metadata: { operationType: 'batch_processing' },
  tags: ['batch', 'important']
});

try {
  // Your code here
  const result = await processData();
  
  // Set span attributes
  span.setAttributes({
    'custom.result_count': result.length,
    'custom.processing_time_ms': Date.now() - startTime
  });
  
} catch (error) {
  // Record error
  span.recordException(error);
  span.setStatus({ code: 2, message: error.message }); // ERROR status
  throw error;
} finally {
  // Always end the span
  span.end();
}
```

### Working with Active Spans

```javascript
import { Laminar } from '@lmnr-ai/lmnr';

// Execute code within a span context
const span = Laminar.startSpan({ name: 'parent' });

await Laminar.withSpan(span, async () => {
  // This code runs with 'span' as the active span
  // Any nested observe() calls or auto-instrumented LLM calls
  // will be children of this span
  
  const result = await someAsyncOperation();
  
  // Set attributes on the active span
  Laminar.setSpanAttributes({
    'operation.success': true,
    'operation.result_size': result.length
  });
});

span.end(); // Don't forget to end the parent span
```

</Tab>
</Tabs>

## Fine-grained control over span creation

If you need absolute control over span creation and completion, Laminar provides methods to start and end spans manually.

<Tabs>
<Tab title="Python">

You can use `Laminar.start_span` to create a span manually.
It doesn't set the span as the current span.
You need to manually set the span as the current span using `Laminar.use_span` context manager.
You also need to manually end the span using `span.end()` method.

```python
from lmnr import Laminar

# Create a span manually (not as current span)
span = Laminar.start_span(name="batch_operation")

try:
    # Use the span as context for nested operations
    with Laminar.use_span(span):
        # This code runs with 'span' as the active span
        result = process_batch() # defined somewhere else
        
        # Set attributes
        span.set_attribute("batch.size", len(result))
        span.set_attribute("batch.success", True)
        
finally:
    # Always end the span
    span.end()
```

</Tab>
<Tab title="JavaScript/TypeScript">

You can use `Laminar.startSpan` to create a span manually.
It doesn't set the span as the current span.
You need to manually set the span as the current span using `Laminar.withSpan` context manager.
You also need to manually end the span using `span.end()` method.
<Tip>
You can use `Laminar.withSpan` to set the manually created span as the current span.
</Tip>

```javascript
import { Laminar } from '@lmnr-ai/lmnr';

const span = Laminar.startSpan({ name: 'operation' });

try {
  // ... your code here ...
  const result = await performOperation(); // defined somewhere else
  
  Laminar.withSpan(span, async () => {

    await observe({ name: 'nested_operation' }, async () => {
      // now `nested_operation` will be a child of `operation` span
    });

  });

  span.setAttributes({
    'operation.result_count': result.length,
    'operation.success': true
  });
  
} finally {
  // Always end the span
  span.end();
}
```

</Tab>
</Tabs>

## Custom Span Hierarchies

Create complex span hierarchies for detailed tracing of multi-step operations:

<Tabs>
<Tab title="Python">

```python
from lmnr import Laminar

def process_workflow(workflow_data):
    with Laminar.start_as_current_span(
        name="workflow_execution",
        input={"workflow_id": workflow_data["id"]}
    ) as workflow_span:
        try:
            # Step 1: Validation
            with Laminar.start_as_current_span(name="validation"):
                validate_workflow(workflow_data)
            
            # Step 2: Processing
            with Laminar.start_as_current_span(name="processing") as processing_span:
                result = process_with_llm(workflow_data)
                
                processing_span.set_attribute("processing.items_count", len(result["items"]))
                processing_span.set_attribute("processing.duration_ms", result["duration"])
            
            # Step 3: Finalization  
            with Laminar.start_as_current_span(name="finalization"):
                finalize_workflow(workflow_data)
            
            # Set workflow-level attributes
            workflow_span.set_attribute("workflow.status", "completed")
            workflow_span.set_attribute("workflow.total_steps", 3)
            
        except Exception as error:
            workflow_span.record_exception(error)
            workflow_span.set_status(trace.Status(trace.StatusCode.ERROR, str(error)))
            raise
```

</Tab>
<Tab title="JavaScript/TypeScript">

```javascript
import { Laminar } from '@lmnr-ai/lmnr';

const processWorkflow = async (workflowData) => {
  const workflowSpan = Laminar.startSpan({
    name: 'workflow-execution',
    metadata: { workflowId: workflowData.id }
  });

  try {
    await Laminar.withSpan(workflowSpan, async () => {
      // Step 1: Validation
      const validationSpan = Laminar.startSpan({ name: 'validation' });
      await Laminar.withSpan(validationSpan, async () => {
        await validateWorkflow(workflowData);
      });
      validationSpan.end();

      // Step 2: Processing  
      const processingSpan = Laminar.startSpan({ name: 'processing' });
      await Laminar.withSpan(processingSpan, async () => {
        const result = await processWithLLM(workflowData);
        
        processingSpan.setAttributes({
          'processing.items_count': result.items.length,
          'processing.duration_ms': result.duration
        });
      });
      processingSpan.end();

      // Step 3: Finalization
      const finalizationSpan = Laminar.startSpan({ name: 'finalization' });
      await Laminar.withSpan(finalizationSpan, async () => {
        await finalizeWorkflow(workflowData);
      });
      finalizationSpan.end();
    });

    workflowSpan.setAttributes({
      'workflow.status': 'completed',
      'workflow.total_steps': 3
    });

  } catch (error) {
    workflowSpan.recordException(error);
    workflowSpan.setStatus({ code: 2, message: error.message });
    throw error;
  } finally {
    workflowSpan.end();
  }
};
```

</Tab>
</Tabs>

## Integration with Existing OpenTelemetry

If your application already uses OpenTelemetry, you can integrate Laminar tracing seamlessly:

<Tabs>
<Tab title="Python">

```python
from opentelemetry import trace
from lmnr import Laminar, use_span

# Get the current OpenTelemetry tracer
tracer = trace.get_tracer("my-application")

# Create an OpenTelemetry span
with tracer.start_as_current_span("existing-operation") as otel_span:
    # Use Laminar's functionality within the existing span
    Laminar.set_span_attributes({
        "lmnr.session.id": session_id,
        "lmnr.user.id": user_id
    })
    
    # Any Laminar auto-instrumentation will create child spans
    # under this existing OpenTelemetry span
    result = call_llm_service()
```

</Tab>
<Tab title="JavaScript/TypeScript">

```javascript
import { trace } from '@opentelemetry/api';
import { Laminar } from '@lmnr-ai/lmnr';

// Get the current OpenTelemetry tracer
const tracer = trace.getTracer('my-application');

// Create an OpenTelemetry span
const otelSpan = tracer.startSpan('existing-operation');

// Use Laminar's withSpan to make it the active span
await Laminar.withSpan(otelSpan, async () => {
  // Now Laminar's auto-instrumentation will create child spans
  // under this existing OpenTelemetry span
  
  // Set Laminar-specific attributes if needed
  Laminar.setSpanAttributes({
    'lmnr.session.id': sessionId,
    'lmnr.user.id': userId
  });
});

otelSpan.end();
```

</Tab>
</Tabs>

## Error Handling and Status

Properly handle errors and set span status for better observability:

<Tabs>
<Tab title="Python">

```python
from opentelemetry import trace

with Laminar.start_as_current_span(name="risky_operation") as span:
    try:
        result = risky_operation()
        
        # Set success status explicitly if needed
        span.set_attribute("operation.result", "success")
        
    except Exception as error:
        # Record the exception details
        span.record_exception(error)
        
        # Add error context
        span.set_attribute("error.type", type(error).__name__)
        span.set_attribute("error.handled", True)
        
        raise  # Re-raise if needed
```

</Tab>
<Tab title="JavaScript/TypeScript">

```javascript
const span = Laminar.startSpan({ name: 'risky-operation' });

try {
  const result = await riskyOperation();
  
  span.setAttributes({ 'operation.result': 'success' });
  
} catch (error) {
  // Record the exception details
  span.recordException(error);
    
  // Add error context
  span.setAttributes({
    'error.type': error.constructor.name,
    'error.handled': true
  });
  
  throw error; // Re-throw if needed
} finally {
  span.end();
}
```

</Tab>
</Tabs>

## Best Practices

### Always End Spans
```python
# ✅ Good - using context manager (automatic cleanup)
with Laminar.start_as_current_span(name="operation"):
    do_work()

# ✅ Good - manual cleanup with try/finally
span = Laminar.start_span(name="operation")
try:
    do_work()
finally:
    span.end()

# ❌ Bad - no cleanup (span never ends)
span = Laminar.start_span(name="operation")
do_work()
```

### Meaningful Span Names
```python
# ✅ Good - descriptive, hierarchical names
with Laminar.start_as_current_span(name="user_registration.email_validation"):
    validate_email()

with Laminar.start_as_current_span(name="user_registration.password_hashing"):
    hash_password()

# ❌ Bad - generic or unclear names  
with Laminar.start_as_current_span(name="process"):
    validate_email()
```

### Rich Attributes
```python
# ✅ Good - structured, queryable attributes
Laminar.set_span_attributes({
    "user.id": user_id,
    "user.tier": "premium", 
    "operation.batch_size": 100,
    "operation.retry_count": 2,
    "feature.experimental_enabled": True
})

# ❌ Bad - unstructured or missing context
Laminar.set_span_attributes({
    "data": "some processing"
})
```

Manual span creation provides the flexibility and control needed for complex tracing scenarios while maintaining compatibility with the broader OpenTelemetry ecosystem.