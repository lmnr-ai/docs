---
title: "Tracing structure"
sidebarTitle: "Overview"
---

## Overview

Effective trace structuring enhances the value of your tracing data, making it easier to debug, analyze, and optimize your LLM applications. This section covers the essential components of trace structuring in Laminar:

| Component | Description |
| --- | --- |
| [Observe](/tracing/structure/observe) | Create a span with `observe` function decorator or wrapper |
| [Manual span creation](/tracing/structure/manual-span-creation) | Create a span manually within a function |
| [Sessions](/tracing/structure/session) | Group related traces together for better organization |
| [User ID](/tracing/structure/user-id) | Associate traces with specific users for targeted analysis |
| [Metadata](/tracing/structure/metadata) | Add contextual information to your traces for filtering and grouping |

## Why Structure Matters

Without structure, each LLM call creates an isolated trace, making it difficult to:
- Understand the relationships between different LLM calls
- Track user journeys through your application
- Debug complex multi-step workflows
- Find relevant traces quickly

Properly structured traces provide a clear picture of your application's flow, making it easier to identify bottlenecks, debug issues, and optimize performance.

## Quickstart

Start by implementing the `observe` wrapper or decorator to create parent spans that group your LLM calls into meaningful traces. Then, enhance these traces with session id, user id, and metadata to create a comprehensive tracing structure.

<Tabs>
<Tab title="JavaScript/TypeScript">
```javascript
// Example: A well-structured trace implementation
import { Laminar, observe } from '@lmnr-ai/lmnr';

// Initialize with your project key
Laminar.initialize({
  projectApiKey: process.env.LMNR_PROJECT_API_KEY,
});

// Create a parent span for the entire request
await observe({ name: 'processUserRequest' }, async (userId, requestId) => {
  // Your LLM calls and other operations will be children of this 'processUserRequest' span
  // and inherit the session id, user id, and metadata

  Laminar.setTraceUserId(userId);

  Laminar.setTraceSessionId(`session-${requestId}`);

  Laminar.setTraceMetadata({
    environment: process.env.NODE_ENV
  });

  // ... you LLM calls here ...
});
```
</Tab>

<Tab title="Python">
```python
import os
from lmnr import Laminar, observe

# Initialize with your project key
Laminar.initialize(
    project_api_key=os.environ["LMNR_PROJECT_API_KEY"]
)

@observe()
def process_user_request(user_id, request_id):  
    # Your LLM calls and other operations will be children of this 'processUserRequest' span
    # and inherit the session id, user id, and metadata.

    Laminar.set_trace_session_id(f"session-{request_id}")

    Laminar.set_trace_user_id(user_id)

    Laminar.set_trace_metadata(
        environment=os.environ.get("ENVIRONMENT", "development")
    )
  
    # ... you LLM calls here ...


# Example usage
process_user_request(user_id="user_123", request_id="req_456")
```
</Tab>
</Tabs>

Explore each component in detail through the links above to implement a comprehensive tracing structure for your LLM applications. 