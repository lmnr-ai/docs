---
title: SDK Reference
description: Complete API reference for the Laminar Python SDK (`lmnr`).
---

# SDK Reference

Complete API reference for the Laminar Python SDK (`lmnr`).

---

## Laminar.initialize()

Initialize Laminar tracing. Call once at application startup.

```python
from lmnr import Laminar

Laminar.initialize(project_api_key="your-key")
```

**Parameters:**

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `project_api_key` | `str` | `LMNR_PROJECT_API_KEY` env | Project API key |
| `base_url` | `str` | `https://api.lmnr.ai` | API base URL |
| `base_http_url` | `str` | `base_url` | HTTP endpoint override |
| `http_port` | `int` | `443` | HTTP port |
| `grpc_port` | `int` | `8443` | gRPC port |
| `instruments` | `set[Instruments]` | All | Instrumentations to enable |
| `disabled_instruments` | `set[Instruments]` | `None` | Instrumentations to disable |
| `disable_batch` | `bool` | `False` | Send spans immediately |
| `max_export_batch_size` | `int` | `64` | Max spans per batch |
| `export_timeout_seconds` | `int` | `30` | Export timeout |
| `set_global_tracer_provider` | `bool` | `True` | Register as global OTEL provider |
| `otel_logger_level` | `int` | `logging.ERROR` | OpenTelemetry log level |
| `session_recording_options` | `SessionRecordingOptions` | `None` | Browser session recording config |
| `force_http` | `bool` | `False` | Use OTLP/HTTP instead of gRPC |

**Environment variables:**
- `LMNR_PROJECT_API_KEY` — Fallback for `project_api_key`
- `LMNR_BASE_URL` — Fallback for `base_url`
- `LMNR_SPAN_CONTEXT` — Attach to upstream trace context
- `OTEL_EXPORTER_OTLP_TRACES_ENDPOINT`, `OTEL_EXPORTER_OTLP_ENDPOINT` — OTEL endpoint overrides

**Note:** Re-calling `initialize()` is a no-op.

---

## @observe()

Decorate a function to create a span. Automatically captures inputs, outputs, and errors.

```python
from lmnr import observe

@observe()
def my_function(param1, param2):
    return param1 + param2

my_function(1, 2)
# Span input: {"param1": 1, "param2": 2}
# Span output: 3
```

**Parameters:**

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `name` | `str` | Function name | Span name |
| `session_id` | `str` | — | Associate trace with session |
| `user_id` | `str` | — | Associate trace with user |
| `metadata` | `dict` | — | Trace metadata (JSON-serializable) |
| `tags` | `list[str]` | — | Span tags |
| `span_type` | `'DEFAULT' \| 'LLM' \| 'TOOL'` | `'DEFAULT'` | Span type |
| `ignore_input` | `bool` | `False` | Don't record input |
| `ignore_output` | `bool` | `False` | Don't record output |
| `ignore_inputs` | `list[str]` | — | Specific parameters to skip |
| `input_formatter` | `Callable` | — | Custom input formatting function |
| `output_formatter` | `Callable` | — | Custom output formatting function |
| `preserve_global_context` | `bool` | `False` | Use global OTEL context instead of isolated |

**Behavior:**
- Function arguments serialized via `orjson` to `lmnr.span.input`
- Return value serialized to `lmnr.span.output`
- Inputs/outputs >10MB are truncated with warning message
- Exceptions recorded as span events with `ERROR` status
- Generators/async generators: yielded parts aggregated for output
- If Laminar not initialized, returns original function unchanged
- Async functions supported automatically

---

## Laminar.start_as_current_span()

Create and activate a span using a context manager. Recommended for most cases.

```python
from lmnr import Laminar

with Laminar.start_as_current_span(name="custom_operation", input=data) as span:
    result = process_data(data)
    Laminar.set_span_output(result)
    # Any spans created here are children of custom_operation
# Span ends automatically
```

**Parameters:**

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `name` | `str` | — | Span name (required) |
| `input` | `Any` | `None` | Span input (JSON-serialized) |
| `span_type` | `'DEFAULT' \| 'LLM' \| 'TOOL'` | `'DEFAULT'` | Span type |
| `tags` | `list[str]` | — | Span tags |
| `parent_span_context` | `LaminarSpanContext \| dict \| str` | — | Parent context for distributed tracing |
| `context` | `Context` | — | OpenTelemetry context |

**Returns:** `Span` (context manager)

---

## Laminar.start_span()

Create a span without activating it. Must end manually.

```python
span = Laminar.start_span(name="custom_operation")
try:
    result = do_work()
    span.set_attribute("result.count", len(result))
finally:
    span.end()
```

**Parameters:** Same as `start_as_current_span`

**Returns:** `Span`

**Note:** Does not attach to context. Combine with `use_span` to activate.

---

## Laminar.start_active_span()

Create a span and immediately activate it. Must end manually.

```python
span = Laminar.start_active_span(name="parent_operation")
try:
    # Any spans created here are children of parent_operation
    do_work()
finally:
    span.end()
```

**Parameters:** Same as `start_as_current_span`

**Returns:** `Span`

**Warning:** Must end span in the same thread/async context it was created. For cross-context use, prefer `start_span` + `use_span`.

---

## Laminar.use_span() / use_span()

Activate an existing span for a block of code.

```python
from lmnr import Laminar, use_span

parent_span = Laminar.start_span(name="parent")

with use_span(parent_span):
    # parent_span is active here
    child_span = Laminar.start_span(name="child")
    do_work()
    child_span.end()

parent_span.end()
```

**Parameters:**

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `span` | `Span` | — | Span to activate |
| `end_on_exit` | `bool` | `False` | End span when context exits |
| `record_exception` | `bool` | `True` | Record exceptions on span |
| `set_status_on_exception` | `bool` | `True` | Set ERROR status on exception |

**Returns:** `Span` (context manager)

---

## Laminar.set_span_attributes(attributes)

Set attributes on the current span.

```python
@observe()
def process_document(doc):
    Laminar.set_span_attributes({
        "document.pages": len(doc.pages),
        "document.language": doc.detected_language,
    })
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `attributes` | `dict[Attributes \| str, Any]` | Key-value pairs. Keys can be `Attributes` enum or strings. Non-primitive values JSON-serialized. |

**Note:** No-op if no active span.

---

## Laminar.set_span_output(output)

Explicitly set span output.

```python
@observe()
def complex_operation():
    result = do_many_things()
    Laminar.set_span_output(result.summary)  # Record only summary
    return result
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `output` | `Any` | Output value (JSON-serialized, truncated if >10MB) |

**Note:** No-op if no active span.

---

## Laminar.set_span_tags() / Laminar.add_span_tags()

Add tags to the current span.

```python
@observe()
def process_input(text: str):
    if len(text) > 10000:
        Laminar.add_span_tags(["long-input"])
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `tags` | `list[str]` | Tags to add (deduplicated) |

**Note:** Warns if not `list[str]`.

---

## span.end()

End a manually created span.

```python
span = Laminar.start_span(name="operation")
try:
    do_work()
finally:
    span.end()  # Always end in finally block
```

---

## span.record_exception(exception)

Record an exception on the span.

```python
with Laminar.start_as_current_span(name="risky_operation") as span:
    try:
        risky_work()
    except Exception as e:
        span.record_exception(e)
        raise
```

---

## span.set_attribute(key, value)

Set a single attribute on a span object.

```python
span.set_attribute("operation.status", "success")
```

---

## Laminar.set_trace_session_id(session_id)

Group this trace with others in a session.

```python
@observe()
def handle_message():
    Laminar.set_trace_session_id("conversation-abc-123")
```

**Note:** Warns if called outside span context.

---

## Laminar.set_trace_user_id(user_id)

Associate trace with a user.

```python
@observe()
def handle_request():
    Laminar.set_trace_user_id("user-456")
```

**Note:** Warns if called outside span context.

---

## Laminar.set_trace_metadata(metadata)

Add key-value metadata to the trace.

```python
@observe()
def handle_request():
    Laminar.set_trace_metadata({
        "environment": "production",
        "region": "us-west",
        "feature_flag": "new-model-v2",
    })
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `metadata` | `dict[str, Any]` | Key-value pairs. Non-primitive values JSON-serialized. |

**Note:** Calling again overwrites previous metadata. Set all keys in one call. Warns if called outside span context.

---

## Laminar.get_trace_id()

Get the current trace ID.

```python
@observe()
def operation():
    trace_id = Laminar.get_trace_id()
    return {"trace_id": trace_id, "result": result}
```

**Returns:** `uuid.UUID | None` — Returns `None` if called outside span context or invalid trace.

---

## Laminar.serialize_span_context(span?)

Serialize span context for cross-service propagation.

```python
@observe()
def service_a():
    context = Laminar.serialize_span_context()
    
    requests.post("http://service-b/api", 
        headers={"X-Laminar-Context": context}
    )
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `span` | `Span` | Optional span (defaults to current) |

**Returns:** `str | None` — JSON string

---

## Laminar.deserialize_span_context(span_context)

Deserialize span context from string or dict.

```python
# In service B
context_str = request.headers.get("X-Laminar-Context")
parent = Laminar.deserialize_span_context(context_str)

with Laminar.start_as_current_span(
    name="service_b_handler",
    parent_span_context=parent
):
    handle_request()
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `span_context` | `dict \| str` | Serialized context |

**Returns:** `LaminarSpanContext`

---

## Laminar.get_laminar_span_context(span?)

Get span context as an object.

```python
context = Laminar.get_laminar_span_context()
# LaminarSpanContext(trace_id, span_id, is_remote, span_path, span_ids_path)
```

**Returns:** `LaminarSpanContext | None`

---

## Laminar.get_laminar_span_context_dict(span?)

Get span context as a dictionary.

**Returns:** `dict | None`

---

## Laminar.flush()

Flush pending spans to the backend.

```python
# At end of script
Laminar.flush()
```

**Returns:** `bool` — Success status

**When to use:**
- End of CLI scripts
- Graceful shutdown of web servers

**When NOT to use:**
- In web server request handlers (degrades performance)

---

## Laminar.force_flush()

Force flush spans, blocking until complete. Resets context.

```python
# In AWS Lambda handler
def handler(event, context):
    Laminar.initialize()
    result = process(event)
    Laminar.force_flush()  # Blocks until spans exported
    return result
```

**Returns:** `None`

**Use for:** AWS Lambda and serverless where background threads may be killed.

**Behavior:** Shuts down and reinitializes span processor internally. Clears isolated context—subsequent spans start new traces.

---

## Laminar.shutdown()

Flush spans and shut down tracing.

```python
Laminar.shutdown()
# Cannot re-initialize in same process
```

**Returns:** `None`

**Note:** Unlike JavaScript SDK, Python SDK cannot re-initialize after shutdown.

---

## Laminar.set_tracing_level(level)

Control what gets traced within a block.

```python
from lmnr import Laminar, TracingLevel

with Laminar.set_tracing_level(TracingLevel.META_ONLY):
    # Inputs and outputs NOT recorded
    # Timing, token counts, costs still recorded
    handle_sensitive_data()

# Normal tracing resumes here
```

**Levels:**

| Level | Behavior |
|-------|----------|
| `TracingLevel.ALL` | Trace everything (default) |
| `TracingLevel.META_ONLY` | Trace metadata only, no inputs/outputs |
| `TracingLevel.OFF` | Disable tracing entirely |

---

## Attributes

Attribute constants for manual LLM span creation.

```python
from lmnr import Laminar, Attributes

Laminar.set_span_attributes({
    Attributes.PROVIDER: "anthropic",
    Attributes.REQUEST_MODEL: "claude-3-5-sonnet",
    Attributes.RESPONSE_MODEL: response["model"],
    Attributes.INPUT_TOKEN_COUNT: response["usage"]["input_tokens"],
    Attributes.OUTPUT_TOKEN_COUNT: response["usage"]["output_tokens"],
})
```

| Constant | Value | Description |
|----------|-------|-------------|
| `PROVIDER` | `gen_ai.system` | LLM provider name |
| `REQUEST_MODEL` | `gen_ai.request.model` | Requested model |
| `RESPONSE_MODEL` | `gen_ai.response.model` | Actual model used |
| `INPUT_TOKEN_COUNT` | `gen_ai.usage.input_tokens` | Input tokens |
| `OUTPUT_TOKEN_COUNT` | `gen_ai.usage.output_tokens` | Output tokens |
| `TOTAL_TOKEN_COUNT` | `gen_ai.usage.total_tokens` | Total tokens |
| `INPUT_COST` | `gen_ai.usage.input_cost` | Input cost |
| `OUTPUT_COST` | `gen_ai.usage.output_cost` | Output cost |
| `TOTAL_COST` | `gen_ai.usage.cost` | Total cost |
| `RESPONSE_ID` | `gen_ai.response.id` | Response ID |

---

## Instruments

Enum of available auto-instrumentations.

```python
from lmnr import Laminar, Instruments

# Enable only specific instruments
Laminar.initialize(
    instruments={Instruments.OPENAI, Instruments.ANTHROPIC}
)

# Disable specific instruments
Laminar.initialize(
    disabled_instruments={Instruments.LANGCHAIN}
)
```

**Available instruments:**
`OPENAI`, `ANTHROPIC`, `BEDROCK`, `COHERE`, `GOOGLE_GENAI`, `GROQ`, `MISTRAL`, `OLLAMA`, `TOGETHER`, `VERTEXAI`, `LANGCHAIN`, `LANGGRAPH`, `LLAMA_INDEX`, `HAYSTACK`, `CREWAI`, `PINECONE`, `QDRANT`, `CHROMA`, `MILVUS`, `WEAVIATE`, `LANCEDB`, `MARQO`, `PLAYWRIGHT`, `PATCHRIGHT`, `BROWSER_USE`, `BROWSER_USE_SESSION`, `SKYVERN`, `CLAUDE_AGENT`, `KERNEL`, `MCP`, and more.

---

## SpanType / TraceType

```python
from lmnr import SpanType, TraceType

# SpanType: DEFAULT, LLM, PIPELINE, EXECUTOR, EVALUATOR, TOOL
# TraceType: DEFAULT, EVALUATION
```

---

## LaminarClient

Synchronous HTTP client for Laminar API operations.

```python
from lmnr import LaminarClient

client = LaminarClient()

# Tag a completed trace
client.tags.tag(trace_id, ["user-feedback-positive"])
```

**Constructor parameters:**

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `project_api_key` | `str` | `LMNR_PROJECT_API_KEY` env | API key |
| `base_url` | `str` | `https://api.lmnr.ai` | API base URL |
| `port` | `int` | From URL | API port |
| `timeout` | `int` | `3600` | Request timeout (seconds) |

**Resources:**
- `client.tags.tag(trace_id, tags)` — Add tags to completed trace
- `client.datasets` — Dataset operations (pull, push)
- `client.evals` — Evaluation operations
- `client.evaluators` — Evaluator CRUD

---

## AsyncLaminarClient

Async variant of `LaminarClient`.

```python
from lmnr import AsyncLaminarClient

client = AsyncLaminarClient()
await client.tags.tag(trace_id, ["feedback"])
await client.close()
```

---

## evaluate()

Run an evaluation against a dataset.

```python
from lmnr import evaluate, LaminarDataset

data = LaminarDataset("my-dataset")

result = evaluate(
    data=data,
    executor=lambda input: my_function(input["query"]),
    evaluators={
        "contains_answer": lambda output, target: target["answer"] in output,
        "is_valid": lambda output: len(output) > 0,
    },
)

print(result["average_scores"])
```

**Parameters:**

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `data` | `EvaluationDataset \| list[Datapoint]` | — | Dataset or list of datapoints |
| `executor` | `Callable` | — | Function to evaluate |
| `evaluators` | `dict[str, Callable \| HumanEvaluator]` | — | Scoring functions |
| `name` | `str` | — | Evaluation name |
| `group_name` | `str` | `'default'` | Group name |
| `metadata` | `dict` | — | Evaluation metadata |
| `concurrency_limit` | `int` | `5` | Parallel executions |
| `project_api_key` | `str` | — | Override API key |
| `max_export_batch_size` | `int` | `64` | Batch size |

**Returns:**
```python
{
    "average_scores": {"evaluator_name": 0.85, ...},
    "evaluation_id": UUID,
    "project_id": UUID,
    "url": "https://...",
}
```

**Note:** If event loop running, returns coroutine. Otherwise runs synchronously.

---

## LaminarDataset

Load a dataset from Laminar.

```python
from lmnr import LaminarDataset

dataset = LaminarDataset("my-dataset", fetch_size=50)
```

**Constructor parameters:**

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `name` | `str` | — | Dataset name or ID |
| `fetch_size` | `int` | `25` | Datapoints per fetch |

**Methods:**
- `push(paths, recursive=False)` — Upload local files to dataset

---

## EvaluationDataset

Abstract base class for custom datasets.

```python
from lmnr import EvaluationDataset, Datapoint

class MyDataset(EvaluationDataset):
    def __len__(self) -> int:
        return len(self.items)
    
    def __getitem__(self, index: int) -> Datapoint:
        return self.items[index]
```

---

## Datapoint

Structure for evaluation data.

```python
from lmnr import Datapoint

point = Datapoint(
    data={"query": "What is 2+2?"},
    target={"answer": "4"},
    metadata={"source": "math"},
)
```

**Fields:**
- `data` — Input data (required)
- `target` — Expected output (optional)
- `metadata` — Additional metadata (optional)
- `id` — UUID (auto-generated)
- `created_at` — Timestamp (auto-generated)

---

## LaminarSpanContext

Span context for distributed tracing.

```python
@dataclass
class LaminarSpanContext:
    trace_id: UUID
    span_id: UUID
    is_remote: bool = False
    span_path: list[str]
    span_ids_path: list[str]
```

---

## SessionRecordingOptions

Browser session recording configuration.

```python
from lmnr import SessionRecordingOptions, MaskInputOptions

options = SessionRecordingOptions(
    mask_input_options=MaskInputOptions(...)
)

Laminar.initialize(session_recording_options=options)
```

---

## Edge Cases

**Input/output size:** Values >10MB replaced with `"Laminar: ... too large to record"`

**Uninitialized:** If `Laminar.initialize()` not called:
- `@observe()` returns original function unchanged
- Manual span methods return `NonRecordingSpan`

**Generators:** `@observe()` aggregates all yielded values for output recording

**Span lifecycle:** `start_span`/`start_active_span` must end in LIFO order. Violating can corrupt context hierarchy.

**Context isolation:** By default, `@observe()` uses isolated context. Set `preserve_global_context=True` to continue existing OTEL traces.

**force_flush:** Clears isolated context. Subsequent spans start new traces.
