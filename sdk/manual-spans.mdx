---
title: Manual Span Creation
description: Create spans manually with Laminar helpers in TypeScript and Python.
---

<Tabs items={['TypeScript', 'Python']}>
  <Tab title="TypeScript">
    ## Laminar.startSpan(options)

    Create a span without activating it. Use for spans you'll pass to other functions.

    ```typescript
    const span = Laminar.startSpan({ name: 'custom_operation' });
    try {
      const result = doWork();
      span.setAttributes({ 'result.count': result.length });
    } finally {
      span.end();
    }
    ```

    **Parameters:**

    | Name | Type | Default | Description |
    |------|------|---------|-------------|
    | `name` | `string` | — | Span name (required) |
    | `input` | `any` | — | Span input (JSON-serialized) |
    | `spanType` | `'DEFAULT'` &#124; `'LLM'` &#124; `'TOOL'` | `'DEFAULT'` | Span type |
    | `tags` | `string[]` | — | Span tags |
    | `userId` | `string` | — | User ID |
    | `sessionId` | `string` | — | Session ID |
    | `metadata` | `Record<string, any>` | — | Metadata |
    | `parentSpanContext` | `string` &#124; `LaminarSpanContext` | — | Parent context |
    | `context` | `Context` | — | OpenTelemetry context |

    **Returns:** `Span`

    **Note:** Not activated—caller must propagate context manually or use `withSpan`.

    ---

    ## Laminar.startActiveSpan(options)

    Create and activate a span. Child spans nest automatically.

    ```typescript
    const span = Laminar.startActiveSpan({ name: 'parent_operation' });
    try {
      // Any spans created here are children of parent_operation
      await doWork();
    } finally {
      span.end();
    }
    ```

    **Parameters:** Same as `startSpan`

    **Returns:** `Span`

    **Note:** Must call `span.end()` (recommend in `finally` block). Context push/pop handled automatically.

    ---

    ## Laminar.withSpan(span, fn, endOnExit?)

    Activate an existing span for the duration of a function.

    ```typescript
    const parentSpan = Laminar.startSpan({ name: 'parent' });

    await Laminar.withSpan(parentSpan, async () => {
      // parentSpan is active here
      const child = Laminar.startSpan({ name: 'child' });
      await doWork();
      child.end();
    });

    parentSpan.end();
    ```

    **Parameters:**

    | Name | Type | Default | Description |
    |------|------|---------|-------------|
    | `span` | `Span` | — | Span to activate |
    | `fn` | `() => T` | — | Function to execute |
    | `endOnExit` | `boolean` | `false` | End span when function completes |

    **Returns:** Return value of `fn` (or `Promise` if async)

    **Note:** Records exception on error. If `endOnExit` is true, span ends after `fn` (awaited if Promise).
  </Tab>
  <Tab title="Python">
    ## Laminar.start_as_current_span()

    Create and activate a span using a context manager. Recommended for most cases.

    ```python
    from lmnr import Laminar

    with Laminar.start_as_current_span(name="custom_operation", input=data) as span:
        result = process_data(data)
        Laminar.set_span_output(result)
        # Any spans created here are children of custom_operation
    # Span ends automatically
    ```

    **Parameters:**

    | Name | Type | Default | Description |
    |------|------|---------|-------------|
    | `name` | `str` | — | Span name (required) |
    | `input` | `Any` | `None` | Span input (JSON-serialized) |
    | `span_type` | `'DEFAULT'` &#124; `'LLM'` &#124; `'TOOL'` | `'DEFAULT'` | Span type |
    | `tags` | `list[str]` | — | Span tags |
    | `parent_span_context` | `LaminarSpanContext` &#124; `dict` &#124; `str` | — | Parent context for distributed tracing |
    | `context` | `Context` | — | OpenTelemetry context |

    **Returns:** `Span` (context manager)

    ---

    ## Laminar.start_span()

    Create a span without activating it. Must end manually.

    ```python
    span = Laminar.start_span(name="custom_operation")
    try:
        result = do_work()
        span.set_attribute("result.count", len(result))
    finally:
        span.end()
    ```

    **Parameters:** Same as `start_as_current_span`

    **Returns:** `Span`

    **Note:** Does not attach to context. Combine with `use_span` to activate.

    ---

    ## Laminar.start_active_span()

    Create a span and immediately activate it. Must end manually.

    ```python
    span = Laminar.start_active_span(name="parent_operation")
    try:
        # Any spans created here are children of parent_operation
        do_work()
    finally:
        span.end()
    ```

    **Parameters:** Same as `start_as_current_span`

    **Returns:** `Span`

    **Warning:** Must end span in the same thread/async context it was created. For cross-context use, prefer `start_span` + `use_span`.

    ---

    ## Laminar.use_span() / use_span()

    Activate an existing span for a block of code.

    ```python
    from lmnr import Laminar, use_span

    parent_span = Laminar.start_span(name="parent")

    with use_span(parent_span):
        # parent_span is active here
        child_span = Laminar.start_span(name="child")
        do_work()
        child_span.end()

    parent_span.end()
    ```

    **Parameters:**

    | Name | Type | Default | Description |
    |------|------|---------|-------------|
    | `span` | `Span` | — | Span to activate |
    | `end_on_exit` | `bool` | `False` | End span when context exits |
    | `record_exception` | `bool` | `True` | Record exceptions on span |
    | `set_status_on_exception` | `bool` | `True` | Set ERROR status on exception |

    **Returns:** `Span` (context manager)
  </Tab>
</Tabs>
